<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="математические-модели-вычислений" class="slide level1">
<h1>Математические модели вычислений</h1>
<h2 id="операторные-схемы-программ">Операторные схемы программ</h2>
<h2 id="схемы-янова">Схемы Янова</h2>
<h2 id="нормальные-алгорифмы-маркова">Нормальные алгорифмы Маркова</h2>
<h2 id="язык-программирования-рефал">Язык программирования Рефал</h2>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
<p><a href="https://maxxk.github.io/formal-models/" class="uri">https://maxxk.github.io/formal-models/</a></p>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#операторная-схема-программы"></a></div>
<section id="операторная-схема-программы" class="slide level1">
<h1>Операторная схема программы</h1>
<p>Классический советский подход к теории программирования, предложенный А.А. Ляпуновым в первом курсе «Принципы программирования», который он читал в 1952/53 году на кафедре вычислительной математики.</p>
<p>В более позднем определении А.П. Ершова:</p>
<p>Задано конечное множество <em>операторов</em> F = { F<sub>1</sub>, …, F<sub>n</sub>}. Входы и выходы описываются в терминах <em>полюсов</em> операторов P = A ∪ R — объединение непересекающихся множеств <em>аргументов</em> A = {a<sub>1</sub>, …, a<sub>p</sub>} и <em>результатов</em> R = { r<sub>1</sub>, …, r<sub>q</sub> }. <em>Распределение полюсов</em> — отображение V : P → F.</p>
<p><em>Граф переходов</em> — ориентированный граф C = (F, J), где J — бинарное отношение, задающее для оператора его преемников по передаче управления.<br>
Компоненты связности графа переходов — отдельные программы в программном комплексе.</p>
<p><em>Скелет</em> программы — набор перечисленных множеств S = (F, C, A, R, V).</p>
<p><em>Память</em> описывается множеством X = { x<sub>1</sub>, …, x<sub>m</sub> } и распределяется среди полюсов отображением L : P → X.</p>
<p>Операторная схема программы — набор G = (S, X, L).</p>
</section><div><a class="slider-prev" href="#математические-модели-вычислений"></a><a class="slider-next" href="#задача-экономии-памяти"></a></div>
<section id="задача-экономии-памяти" class="slide level1">
<h1>Задача экономии памяти</h1>
<p>А.П. Ершов в книге (список литературы на последних слайдах) рассматривает задачу экономии памяти: каким образом можно использовать минимальное множество памяти X, сохраняя семантику программы?</p>
<p>Постановка задачи: по заданной схеме программы с <em>распределением памяти</em> L построить новое распределение памяти L', использующее, по возможности, память меньшего объёма.</p>
<p><em>Информационный граф</em> I = (P, M) — двудольный граф M ⊂ R×A, который сопоставляет результаты оператора с аргументами его преемников. <em>Маршрут информационной связи</em> — путь в информационном графе, задаётся первым результатом и последним аргументом.</p>
<p>Компоненты связности информационного графа называются <em>областями действия</em>.</p>
<p>Области действия <em>несовместимы</em> тогда и только тогда, когда в каждой из них найдутся результаты r и r', соответственно, такие, что:</p>
<ul>
<li class="fragment">V(r) = V(r') или</li>
<li class="fragment">V(r) — внутренний оператор маршрута информационной связи (r', a')</li>
<li class="fragment">V(r') — внутренний оператор маршрута информационной связи (r, a)</li>
</ul>
<p>Задача экономии памяти решается выделением несовместимых областей действия раскраской графа и объединением совместимых областей действия.</p>
</section><div><a class="slider-prev" href="#операторная-схема-программы"></a><a class="slider-next" href="#схема-янова"></a></div>
<section id="схема-янова" class="slide level1">
<h1>Схема Янова</h1>
<p>Модификация операторной схемы программ.<br>
Область приложения — исследование способов задания условий в программе и эквивалентных преобразований программ с условиями.</p>
<p>Не рассматривается понятие памяти и распределения памяти. Все операторы одноместны, принимают на вход исходное состояние памяти и возвращают полностью изменённое состояние.</p>
<p>Вводятся счётные множества <em>предикатных символов</em> <strong>P</strong> = { p<sub>1</sub>, p<sub>2</sub>, … } и <em>операторных символов</em> <strong>A</strong> = { A<sub>1</sub>, A<sub>2</sub>, … }.</p>
<p><em>Оператор</em> A = A(P) — пара из операторного символа A и некоторого (возможно, пустого) множества предикатных символов P, которое называется <em>сдвигом</em> оператора A.</p>
</section><div><a class="slider-prev" href="#задача-экономии-памяти"></a><a class="slider-next" href="#схема-янова-1"></a></div>
<section id="схема-янова-1" class="slide level1">
<h1>Схема Янова</h1>
<p><em>Граф переходов</em> — ориентированный граф, множество вершин которого состоит из неотрицательного числа <em>преобразователей</em>, <em>распознавателей</em> и одного <em>останова</em>. Из преобразователя выходит в точности одна дуга, из распознавателя — две различные (<em>плюс-стрелка</em> и <em>минус-стрелка</em>). Выделяется одна <em>входная</em> вершина графа и помечается <em>входной стрелкой</em>.</p>
<p><em>Преобразователи</em> помечены операторными символами, <em>распознаватели</em> помечены логическими формулами над <em>предикатными</em> символами.</p>
<p><em>Схема Янова</em> G(p<sub>1</sub>, …, p<sub>k</sub>)</p>
</section><div><a class="slider-prev" href="#схема-янова"></a><a class="slider-next" href="#схема-янова-2"></a></div>
<section id="схема-янова-2" class="slide level1">
<h1>Схема Янова</h1>
<p><img src="http://pco.iis.nsk.su/wiki/images/8/80/Yanov_schemata.gif"></p>
</section><div><a class="slider-prev" href="#схема-янова-1"></a><a class="slider-next" href="#семантика-схемы-янова"></a></div>
<section id="семантика-схемы-янова" class="slide level1">
<h1>Семантика схемы Янова</h1>
<p>Для того, чтобы схема задавала программу, необходимо дать <em>интерпретацию</em> операторным и предикатным символам, и описать алгоритм выполнения интерпретированной схемы.</p>
<p>Дано некоторое множество <em>состояний памяти</em> D.<br>
Предикатные символы p<sub>i</sub> соответствуют предикатам π<sub>i</sub> : D → { <strong>f</strong>, <strong>t</strong> }. Сами p<sub>i</sub> в программе назовём <em>предикатными переменными</em>.</p>
<p>Операторным символам A<sub>j</sub> сопоставляются (возможно, частичные) функции φ<sub>j</sub> : D → D</p>
</section><div><a class="slider-prev" href="#схема-янова-2"></a><a class="slider-next" href="#выполнение-схемы-янова"></a></div>
<section id="выполнение-схемы-янова" class="slide level1">
<h1>Выполнение схемы Янова</h1>
<p><strong>Начальный шаг.</strong> Берём произвольное d ∈ D в качестве исходного состояния памти и присваиваем значения всем предикатным переменным p<sub>i</sub> ≡ π<sub>i</sub>(d). Передаём управление на входную вершину графа переходов.</p>
<p><strong>Шаг выполнения.</strong> Пусть d — текущее состояние памяти, Δ = (σ<sub>1</sub>, …, σ<sub>k</sub>) — текущие значения предикатных переменных, S — текущая вершина графа переходов.</p>
<ol type="1">
<li class="fragment">Если S — останов, то выполнение завершается, и d является результатом выполнения схемы в данной интерпретации.</li>
<li class="fragment">Если S — распознаватель с условием F(p<sub>1</sub>, …, p<sub>k</sub>). Вычисляем σ = F(Δ) и передаём управление по плюс-стрелке, если σ=<strong>t</strong> и по минус-стрелке, если σ=<strong>f</strong>.</li>
<li class="fragment">Если S — преобразователь A<sub>j</sub>(P<sub>j</sub>), вычисляем новое состояние памяти d' = φ<sub>j</sub>(d) и значения предикатных переменных в сдвиге P<sub>j</sub> : p<sub>i</sub> ≡ π<sub>i</sub>(d'). Управление передаётся на следующую вершину графа.</li>
</ol>
<p>Таким образом, получена частичная функция d = <strong>F</strong><sub>G,I</sub>(d<sub>0</sub>).</p>
</section><div><a class="slider-prev" href="#семантика-схемы-янова"></a><a class="slider-next" href="#эквивалентность-схем"></a></div>
<section id="эквивалентность-схем" class="slide level1">
<h1>Эквивалентность схем</h1>
<p>Схемы G<sub>1</sub> и G<sub>2</sub> <em>сравнимы</em>, если они заданы над одним и тем же множеством предикатных символов, а также у одинаковых операторов совпадают сдвиги.</p>
<p>Две сравнимые схемы <em>эквивалентны</em> в некоторой совместной интерпретации I, если F<sub>G1,I</sub>(d) = F<sub>G2,I</sub>(d).</p>
<p>Две сравнимые схемы <em>функционально эквивалентны</em>, если они эквивалентны в любой совместной интерпретации.</p>
<p><em>Операционная история</em> (след) интерпретированной схемы Янова H<sub>G,I</sub>(d) — полная последовательность выполняемых операторов и наборов значений функциональных переменных. Для исключения циклов вершины графа помечаются наборами значений предикатных переменных. Если при выполнении мы попали в вершину, помеченную таким же набором значений, что и текущий набор Δ, считаем, что мы попали в бесконечный цикл.</p>
<p>Две сравнимые схемы <em>операционно эквивалентны</em>, если они одинаково работают в любой совместной интерпретации, т.е.<br>
H<sub>G1,I</sub>(d) = H<sub>G2,I</sub>(d).</p>
<p><strong>Теорема.</strong> Функциональная эквивалентность равносильна операционной эквивалентности.</p>
</section><div><a class="slider-prev" href="#выполнение-схемы-янова"></a><a class="slider-next" href="#эквивалентность-схем-1"></a></div>
<section id="эквивалентность-схем-1" class="slide level1">
<h1>Эквивалентность схем</h1>
<p><em>Конфигурации</em> схемы k ∈ K(G) строятся аналогично операционным историям, но без заданной интерпретации индуктивно:</p>
<p><strong>Начальный шаг.</strong> Выберем произвольный набор исходных значений предикатных переменных Δ.<br>
<strong>Очередной шаг.</strong> Текущий набор Δ, текущая вершина S. Уже обработанные вершины помечены.</p>
<ol type="1">
<li class="fragment">Если S — помеченный распознаватель, то мы попали в пустой цикл и конфигурация не может быть построена.</li>
<li class="fragment">Если S — непомеченный распознаватель с условием F, помечаем его, вычисляем F(Δ) и переходим к вершине-преемнику.</li>
<li class="fragment">Если S — останов, построение конфигурации завершено.</li>
<li class="fragment">Если S — оператор, то записываем A<sub>i</sub> в конфигурацию, и в качестве нового значения Δ' помещаем произвольный набор, образующий с набором Δ допустимую пару для оператора A<sub>i</sub>.</li>
</ol>
<p>Две сравнимые схемы <em>формально эквивалентны</em>, если их множества их конфигураций совпадают.</p>
<p><strong>Теорема.</strong> Функциональная эквивалентность равносильна формальной эквивалентности.</p>
</section><div><a class="slider-prev" href="#эквивалентность-схем"></a><a class="slider-next" href="#эквивалентные-преобразования"></a></div>
<section id="эквивалентные-преобразования" class="slide level1">
<h1>Эквивалентные преобразования</h1>
<p>Вводится набор из 13 аксиом и 5 правил вывода, определяющий все примитивные эквивалентные преобразования схем Янова.</p>
<p><strong>Теорема.</strong> Для любых двух эквивалентных схем Янова можно построить последовательность эквивалентных преобразований, которые приводят их к общему виду.</p>
<p><strong>Теорема.</strong> Задача эквивалентности двух сравнимых схем Янова разрешима.</p>
</section><div><a class="slider-prev" href="#эквивалентность-схем-1"></a><a class="slider-next" href="#алгорифмы-маркова"></a></div>
<section id="алгорифмы-маркова" class="slide level1">
<h1>Алгорифмы Маркова</h1>
<p>Пусть задан конечный алфавит <strong>A</strong>, не содержащий символов «перевод строки» (γ), «→» и «→.». Нормальным алгорифмом назовём последовательность <em>формул подстановки</em> вида:</p>
<p>&lt; строка <strong>A<sup>*</sup></strong> &gt; (образец) → &lt; строка <strong>A<sup>*</sup></strong> &gt; (результат)<br>
&lt; строка <strong>A<sup>*</sup></strong> &gt; → . (останов) &lt; строка <strong>A<sup>*</sup></strong> &gt;</p>
<p>На вход алгорифма подаётся строка <strong>A<sup>*</sup></strong>. Далее для каждого правила по порядку выполняется поиск образца в строке слева.</p>
<p>Если образец найден, т.е. для правила L → D входная строка T представлена в виде T = R · L · S, то подстрока L заменяется на D и результатом шага объявляется строка T' = R · D · S. Если стрелка — стрелка останова, то выполнение завершается с результатом T', в противном случае выполняется следующий шаг (просмотр образцов сначала).</p>
<p>Если образец не найден, переходим к следующему правилу.</p>
<p>Если ни для одного правила образец не найдет, выполнение завершается с результатом T.</p>
</section><div><a class="slider-prev" href="#эквивалентные-преобразования"></a><a class="slider-next" href="#примеры"></a></div>
<section id="примеры" class="slide level1">
<h1>Примеры</h1>
<ol type="1">
<li class="fragment"><p>Алгоритм получения модуля унарных чисел N, M.<br>
На вход подаётся строка N<em>M, где N и M — унарные числа в алфавите 1.<br>
1 </em> 1 → *<br>
* → .</p></li>
<li class="fragment"><p>Алгоритм поиска наибольшего общего делителя чисел N<em>M. Пусть a, b, c – служебные символы.<br>
1 a → a 1<br>
1 </em> 1 → a <em><br>
1 </em> → * b<br>
b → 1<br>
a → c<br>
c → 1<br>
* → .</p></li>
</ol>
<p>Визуализатор:<br>
<a href="http://cmcmsu.no-ip.info/1course/alg.schema.nam.htm#" class="uri">http://cmcmsu.no-ip.info/1course/alg.schema.nam.htm#</a></p>
</section><div><a class="slider-prev" href="#алгорифмы-маркова"></a><a class="slider-next" href="#рефал"></a></div>
<section id="рефал" class="slide level1">
<h1>Рефал</h1>
<p>— [РЕкурсивных Функций АЛгоритмический] язык программирования, построенный на основе модели нормальных алгорифмов Маркова.</p>
<p>Функции задаются в терминах правил переписывания входных строк (деревьев) в выходные.<br>
Последовательность правил, разделённых символом <code>;</code>. Слева от знака <code>=</code> записываются образцы, справа — результаты. После унификации входной строки с образцом выполняется подстановка полученных значений переменных в результат. Вызов функции — в угловых скобках, круглые скобки позволяют задавать и сопоставлять деревья и образцы на деревьях.</p>
<p>Для наглядности знак <code>=</code> заменён на →</p>
<pre><code>Beta {
   (λ s.var '.'  e.body) t.value e.rest -&gt;
      Step &lt;Subst s.var t.value e.body&gt; e.rest ;
    → Stuck;
}</code></pre>
<p><span class="small"><br>
Турчин В. Ф. «Метаалгоритмический язык». Кибернетика, вып. 4 (1968 г.): 45–54.<br>
</span></p>
</section><div><a class="slider-prev" href="#примеры"></a><a class="slider-next" href="#рефал-1"></a></div>
<section id="рефал-1" class="slide level1">
<h1>Рефал</h1>
<p>В образцах можно задавать переменные:</p>
<ul>
<li class="fragment"><code>s.имя-переменной</code> принимает любой символ, не являющийся скобкой</li>
<li class="fragment"><code>t.имя-переменной</code> (терм) принимает любой символ, или парные скобки с их содержимым</li>
<li class="fragment"><code>e.имя-переменной</code> выполняет поиск. На первом шаге <code>e</code>-переменная пуста. Если не удалось сопоставить образец, <code>e</code>-переменная расширяется на следующий терм.</li>
</ul>
<p>При успешном сопоставлении с образцом, значения переменных можно использовать при генерации результата.</p>
<pre><code>Beta {
   (λ s.var '.'  e.body) t.value e.rest -&gt;
      Step &lt;Subst s.var t.value e.body&gt; e.rest ;
    → Stuck;
}</code></pre>
<p>Н.М. Нагорный: алгорифмы Маркова можно эквивалентным образом задавать в виде нескольких конечных наборов правил подстановок [«функций»], бесконечного количества [функций] и бесконечного набора бесконечных функций.</p>
</section><div><a class="slider-prev" href="#рефал"></a><a class="slider-next" href="#расширения-базового-рефала"></a></div>
<section id="расширения-базового-рефала" class="slide level1">
<h1>Расширения Базового Рефала</h1>
<p>Условия: промежуточный результат сопоставляется с образцом (Рефал-5):</p>
<pre><code>t.neutral e.rest,
  &lt;Beta e.rest&gt; : s.state e.result =
  s.state t.neutral e.result ;</code></pre>
<p>Функции высшего порядка: функции передаются так же, как и данные (Рефал-7):</p>
<pre><code>(e.1) e.rest,
  &lt;Beta e.1&gt; : e.betaResult =
  &lt;{
    Step e.result = Step (e.result) e.rest ;
    Stuck e.result,
      &lt;Beta e.rest&gt; : s.state e.result2 =
      s.state (e.result) e.result2 ;
  } e.betaResult&gt;;</code></pre>
<p><span class="small"><br>
Рефал-5: В.Ф. Турчин. «Рефал-5. Руководство по программированию и справочник» <a href="http://refal.net/rf5_frm.htm" class="uri">http://refal.net/rf5_frm.htm</a><br>
Рефал-7: С.Ю. Скоробогатов, А. М. Чеповский. «Разработка нового диалекта языка Refal». Информационные технологии, вып. 9 (2006 г.): 31–38.<br>
</span></p>
</section><div><a class="slider-prev" href="#рефал-1"></a><a class="slider-next" href="#метавычисления-и-суперкомпиляция"></a></div>
<section id="метавычисления-и-суперкомпиляция" class="slide level1">
<h1>Метавычисления и суперкомпиляция</h1>
<p>Метавычисления — это раздел теории и практики программирования, связанный с разработкой и использованием метапрограмм — конструктивных метасистем над программами.<sup>1</sup></p>
<p>Суперкомпиляция — техника преобразования программ [в первую очередь — оптимизации], основанная на построении полной и самодостаточной модели программы.<sup>2</sup></p>
<p>Две основные стадии суперкомпиляции:</p>
<ol type="1">
<li class="fragment"><em>Прогонка</em> программы на параметризованных входных данных (частичная специализация). Выполняется построение множетсва конфигураций машины.</li>
<li class="fragment"><em>Свёртка</em> результата прогонки для получения остаточной программы (выделение рекурсии).</li>
</ol>
<p><span class="small"><br>
<sup>1</sup> С.М. Абрамов. Основы метавычислений. Курс НОУ ИНТУИТ. <a href="http://www.intuit.ru/studies/courses/1067/221/info" class="uri">http://www.intuit.ru/studies/courses/1067/221/info</a><br>
<sup>2</sup> И.Г. Ключников. Суперкомпиляция: идеи и методы. Практика функционального программирования, № 7, 2011.<br>
</span></p>
</section><div><a class="slider-prev" href="#расширения-базового-рефала"></a><a class="slider-next" href="#кибернетические-основания-математики"></a></div>
<section id="кибернетические-основания-математики" class="slide level1">
<h1>Кибернетические основания математики</h1>
</section><div><a class="slider-prev" href="#метавычисления-и-суперкомпиляция"></a><a class="slider-next" href="#система-типов-для-языков-семейства-рефал"></a></div>
<section id="система-типов-для-языков-семейства-рефал" class="slide level1">
<h1>Система типов для языков семейства Рефал</h1>
<p>Ограничимся функциями без побочных эффектов. Тип значения — завершимая функция, принимающая или отвергающая значение.</p>
<pre><code>Bool = { 0 = ; 1 = ; }</code></pre>
<p>Тип функций задаёт допустимый набор типов аргумента и типов выходных значений (разделены знаком <code>--</code>) Суждение «функция f обладает типом g» означает, что для любого входного значения, распознаваемого g, f завершится без ошибок, и её возвращаемое значение будет распознано соответствующим типом для g.</p>
<pre><code>BoolBinaryOperation = { s.1 s.2, &lt;Bool s.1&gt; &lt;Bool s.2&gt; -- s.3, &lt;Bool s.3&gt; }
BoolIdentity = { s.1, &lt;Bool s.1&gt; -- s.1 }</code></pre>
</section><div><a class="slider-prev" href="#кибернетические-основания-математики"></a><a class="slider-next" href="#суждение-типизации"></a></div>
<section id="суждение-типизации" class="slide level1">
<h1>Суждение типизации</h1>
<p>— применение суперкомпиляции к типу и функции на произвольном выражении.</p>
<pre><code>BoolBinaryOperation ≡ { t.FN = { s.1 s.2, &lt;Bool s.1&gt; &lt;Bool s.2&gt; : s.1 s.2 = &lt;t.FN s.1 s.2&gt; : s.3, &lt;Bool s.3&gt; = ;
  e.skip = ; } }
&lt;HasType BoolBinaryOperation F&gt; ≡ &lt; Supercompile [&lt;BoolBinaryOperation F&gt; e.1] &gt;</code></pre>
<p>Последний образец <code>e.skip</code> срабатывает в случае, если входные данные не удовлетворяют условиям типа.<br>
Возможные случаи:</p>
<ol type="1">
<li class="fragment">Успешная типизация: Суперкомпиляция уничтожает вызов функции t.FN, результат — общезначимый тип <code>{ e.1 = }</code>.</li>
<li class="fragment">Ошибка типизации: Суперкомпиляция приходит к возможному контрпримеру <code>{ … = &lt; &gt; ; … }</code></li>
<li class="fragment">Неопределённый результат: Суперкомпиляция не может уничтожить вызов функции и генерирует нетривиальную остаточную программу. <code>R ≡ { … ; … }</code>. В этом случае можно предоставить дополнительные данные в исходном определении, или в определении R':</li>
</ol>
<pre><code>&lt;HasType T F&gt; ⟶ R
&lt;HasType T F R'&gt; ⟶ &lt;HasType R' &lt;Supercompile [&lt;T F&gt; e.1]&gt;&gt; &lt;HasType { e.1 = } R'&gt;</code></pre>
</section><div><a class="slider-prev" href="#система-типов-для-языков-семейства-рефал"></a><a class="slider-next" href="#подтипы"></a></div>
<section id="подтипы" class="slide level1">
<h1>Подтипы</h1>
<p>Наиболее точный тип можно получить из определения функции.</p>
<pre><code>XorDef = { 0 0 = 0 ; 0 1 = 1; 1 0 = 1; 1 1 = 0; }
XorSpec = { 0 0 -- 0; 0 1 -- 1; 1 0 -- 1; 1 1 -- 0; }</code></pre>
<p>Другие типы могут, например, более свободно трактовать возможные выходные значения, или же задавать дополнительные ограничения на входные значения и получать таким образом дополнительные свойства выходных значений. Фактически, тип — это свойство функции (утверждение о функции).</p>
<pre><code>XorNeg = { 1 s.1 -- s.2, &lt;Not s.1&gt; : s.2 }</code></pre>
<p>Можно попытаться получить XorNeg ⩽ XorSpec, в терминах пересечения спецификаций:</p>
<pre><code>&lt;HasType XorNeg XorSpec&gt;</code></pre>
</section><div><a class="slider-prev" href="#суждение-типизации"></a><a class="slider-next" href="#проверка-на-завершимость"></a></div>
<section id="проверка-на-завершимость" class="slide level1">
<h1>Проверка на завершимость</h1>
<p>Индуктивные типы.</p>
<pre><code>ℕ {
  = ;
  1 e.1, &lt;ℕ e.1&gt; : = 1 e.1
}</code></pre>
<p>Известные условия завершимости:</p>
<ol type="1">
<li class="fragment">Длина аргумента: функция F завершима, если в рекурсивных вызовах используется только убывающий по длине аргумент.</li>
<li class="fragment">Размер аргумента: функция F завершима, если на аргументах можно определить другую функцию G : dom F → ℕ, такую, что в рекурсивных вызовах используется аргумент меньшего размера.</li>
<li class="fragment">Трансфинитная индукция.</li>
</ol>
</section><div><a class="slider-prev" href="#подтипы"></a><a class="slider-next" href="#λ-исчисление-с-зависимыми-типами"></a></div>
<section id="λ-исчисление-с-зависимыми-типами" class="slide level1">
<h1>λ-исчисление с зависимыми типами</h1>
<p>Для определения типов функций высшего порядка введём понятие функциональной переменной <code>f</code>, сопоставление которой успешно в точности для функций.<br>
Определим виды, типы и термы λ-исчисления с зависимыми типами в виде трансляции<br>
⟦ Type ⟧ = Type { f.FN, &lt; Finite f.FN &gt; -- f.FN }<br>
В качестве контекстов используем простую последовательность переменных:<br>
⟦ (x : A), (y : B), … ⟧ = t.x t.y …, &lt; Type ⟦A⟧ &gt; &lt; Type ⟦B ⟧&gt; … &lt; HasType s.x ⟦A⟧ &gt; &lt; HasType s.y ⟦B⟧ &gt; …<br>
⟦ Var v ⟧ = t.v<br>
⟦ Π(x : A).B ⟧ = { t.x, &lt; HasType Type ⟦A⟧ &gt; &lt; HasType ⟦A⟧ t.x &gt; -- t.b, &lt; HasType Type ⟦B⟧ &gt; &lt; HasType ⟦B⟧ t.b &gt; }<br>
⟦ λ(x : A).N ⟧ = { t.x, &lt; HasType Type ⟦A⟧ &gt; &lt; HasType ⟦A⟧ t.x &gt; = ⟦ N ⟧ }<br>
⟦ M N ⟧ = &lt; ⟦M⟧ ⟦N⟧ &gt;</p>
</section><div><a class="slider-prev" href="#проверка-на-завершимость"></a><a class="slider-next" href="#нетривиальные-правила-редукции"></a></div>
<section id="нетривиальные-правила-редукции" class="slide level1">
<h1>Нетривиальные правила редукции</h1>
s =<sub>A</sub> t ⇔ I — отношение структуры типа идентичности между элементами типа A (элементы типа идентичности s = t имеют структуру типа I(s, t)).<br>

<table style="font-size: 0.8em">
<tbody><tr>
<td>
J(B, u, v, a =<sub>A</sub> b, ξ, x) ⟶ <strong>let</strong><br>
<span class="math inline">  </span> A<sub>1</sub> ≡ A(u, <strong>refl</strong> u)<br>
<span class="math inline">  </span> A<sub>2</sub> ≡ A(v, ξ)<br>
<span class="math inline">  </span> s =<sub>A2</sub> t ⇔ I<sub>2</sub><br>
<span class="math inline">  </span> a<sub>1</sub> ≡ a(u, <strong>refl</strong> u) : A<sub>1</sub><br>
<span class="math inline">  </span> a<sub>2</sub> ≡ a(v, ξ) : A<sub>2</sub><br>
<span class="math inline">  </span> a'<sub>1</sub> ≡ J(B, u, v, A, ξ, a<sub>1</sub>) : A<sub>2</sub><br>
<span class="math inline">  </span> b<sub>1</sub> ≡ b(u, <strong>refl</strong> u) : A<sub>1</sub>
</td>
<td>
<span class="math inline">  </span> b<sub>2</sub> ≡ b(v, ξ) : A<sub>2</sub><br>
<span class="math inline">  </span> b'<sub>1</sub> ≡ J(B, u, v, A, ξ, b<sub>1</sub>) : A<sub>2</sub><br>
<span class="math inline">  </span> x<sub>1</sub> ≡ <strong>itoe</strong>(<strong>refl</strong> a'<sub>1</sub>) : I<sub>2</sub>(a'<sub>1</sub>, a'<sub>1</sub>)<br>
<span class="math inline">  </span> x<sub>2</sub> : I<sub>2</sub>(a'<sub>1</sub>, b'<sub>1</sub>)<br>
<span class="math inline">  </span> x<sub>2</sub> ≡ J(A<sub>1</sub>, a<sub>1</sub>, b<sub>1</sub>, (r, ρ) ↦ I<sub>2</sub>(a'<sub>1</sub>, J(B, u, v, A, ξ, r)), x, x<sub>1</sub>)<br>
<span class="math inline">  </span> z ≡ λ (w : B) (ω : v =<sub>B</sub> w) (a<sub>wω</sub> : A(w, ω)). J(B, w, v, A, ξ ∘ ω<sup>-1</sup>, a<sub>wω</sub>)<br>
<span class="math inline">  </span> x<sub>3</sub> ≡ J(B, u, v, (r, ρ) ↦ I<sub>2</sub>(z(r, ρ, a(r, ρ)), b'<sub>1</sub>), ξ, x<sub>2</sub>)<br>
<span class="math inline">  </span> <strong>in</strong> J(B, u, v, I<sub>2</sub>(a<sub>2</sub>, z · b), ξ, x<sub>3</sub>) <span class="math inline">  </span> .
</td>
</tr>
</tbody></table>
<p>Как исследовать поведение таких сложных правил?</p>
<span class="small"><br>
Правило редукции переноса вдоль идентичности ξ : u =<sub>B</sub> v элемента другого типа идентичности x : a(t, σ) =<sub>A</sub> b(t, σ).
<div style="display: inline-block">
В. А. Васенин,
</div>
<div style="display: inline-block">
М. А. Кривчиков.
</div>
<p>«Предметно-ориентированные языки с заданной формальной семантикой на основе лямбда-исчисления с зависимыми типами». Международная конференция «Мальцевские чтения-2014», Новосибирск, 2014.<br>
</p>
</span></section><div><a class="slider-prev" href="#λ-исчисление-с-зависимыми-типами"></a><a class="slider-next" href="#проверка-типов"></a></div>
<section id="проверка-типов" class="slide level1">
<h1>Проверка типов</h1>
<p>Методы суперкомпиляции требуют адаптации для работы с функциями высших порядков.<br>
Схема обоснования существования метода суперкомпиляции:</p>
<ol type="1">
<li class="fragment"><p>Для типов-значений с ограничениями (без перебора и с раскрытием переменных типа <code>t</code>)<sup>1</sup><br>
Определен. Существует также суперкомпилятор SCP4, который работает на языке Рефал-5.<sup>2</sup></p></li>
<li class="fragment"><p>Новые функциональные переменные <code>f.1</code> в образцах имеют семантику, аналогичную образцу-паре скобок <code>(e.1)</code>, с единственным отличием — распознаются функциональные скобки. Функциональные переменные непрозрачны для сопоставления с образцом.</p></li>
<li class="fragment"><p>Суждения типизации для функциональных переменных пока не раскрываются, записываются в контекст синтаксически.</p></li>
</ol>
<p>Тип ложных высказываний — «пустая» функция с единственной инструкцией <code>FAIL</code>. Тип истинных высказываний — общезначимая функция <code>{ e.1 = }</code>.</p>
<p><span class="small"><br>
<sup>1</sup> А.П. Немытых. О суперкомпиляции (к 80-летию со дня рождения В.Ф. Турчина). Международная конференция<br>
"Современные проблемы математики, информатики и биоинформатики", Новосибирск, 2011.<br>
<sup>2</sup> А.П. Немытых. Суперкомпилятор SCP-4. Общая структура. М.: URSS. 2007. 152 с.<br>
</span></p>
</section><div><a class="slider-prev" href="#нетривиальные-правила-редукции"></a><a class="slider-next" href="#связанные-работы"></a></div>
<section id="связанные-работы" class="slide level1">
<h1>Связанные работы</h1>
<p>Автоматическая верификация с использованием методов суперкомпиляции (ближе к теоретико-модельным методам):</p>
<ul>
<li class="fragment">Климов А.В., Ключников И.Г., Романенко С.А. Автоматизированная верификация счетчиковых систем посредством предметно-ориентированной многорезультатной суперкомпиляции.</li>
<li class="fragment">A. P. Lisitsa and A. P. Nemytykh. Towards verification via supercompilation. In Proceedings of the 29th Annual International Computer Software and Applications Conference (COMPSAC’05), 25-28 July 2005, Edinburgh, Scotland, UK, pages 9–10. IEEE Computer Society, 2005.</li>
</ul>
<p>Методы суперкомпиляции для автоматизированного доказательства эквивалентности термов в λ-исчислении высших порядков (без зависимых типов):</p>
<ul>
<li class="fragment">I. G. Klyuchnikov and S. A. Romanenko. Proving the equivalence of higher-order terms by means of supercompilation. In Pnueli et al. [33], pages 193–205. 2009</li>
</ul>
</section><div><a class="slider-prev" href="#проверка-типов"></a><a class="slider-next" href="#литература"></a></div>
<section id="литература" class="slide level1">
<h1>Литература</h1>
<p>Схемы программ: А. П. Ершов. Введение в теоретическое программирование: беседы о методе. М.: Наука, 1977. 288 С.</p>
<p>Алгорифмы Маркова: А. А. Марков, Н. М. Нагорный. Теория алгорифмов. М.: Наука, 1984. 432 С.</p>
<p>Язык программирования Рефал: <a href="http://www.refal.net/rf5_frm.htm" class="uri">http://www.refal.net/rf5_frm.htm</a></p>
<p>Дополнительно: Turchin V.F. Cybernetic Foundations of Mathematics. 1983 (unpublished).</p>
</section><div><a class="slider-prev" href="#связанные-работы"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#математические-модели-вычислений" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>
