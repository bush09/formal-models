<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="slider.css">
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
  <div style="width: 640px;height: 400px;">
  <input id="slider-max" type="checkbox" checked="">
   <article class="slider slider-indicator">
   <a id="slider-default"></a>
   <label for="slider-max" title="Maximize"></label>


<section id="математические-модели-вычислений" class="slide level1">
<h1>Математические модели вычислений</h1>
<h2 id="расширения-типизированного-λ-исчисления">Расширения типизированного λ-исчисления</h2>
<h2 id="λ-исчисление-с-конструкторами-типов">λ-исчисление с конструкторами типов</h2>
<h2 id="λ-исчисление-с-зависимыми-типами">λ-исчисление с зависимыми типами</h2>
<p><a href="mailto:maxim.krivchikov@gmail.com" class="email">maxim.krivchikov@gmail.com</a></p>
<a href="https://maxxk.github.io/formal-models/" class="uri">https://maxxk.github.io/formal-models/</a><br>

<style>
.inference table {
    display: inline-block;
    padding: 1em;
}

.inference table th {
    font-weight: normal;
    border-bottom: 1px solid black;
}
</style>
</section><div><a class="slider-prev"></a><a class="slider-next" href="#система-f-λ2-прошлое-занятие"></a></div>
<section id="система-f-λ2-прошлое-занятие" class="slide level1 inference">
<h1>Система F (λ2, прошлое занятие)</h1>
<div style="font-size: 0.9em">
<p><br><span class="math display"><em>τ</em> ≡  <em>b</em> | <em>τ</em><sub>1</sub> → <em>τ</em><sub>2</sub> | <em>α</em> | ∀<em>α</em>.<em>τ</em>,   <em>b</em> ∈ <em>B</em>.</span><br></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">  </span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">[] wf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">  </span> τ ∈ Γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, x : τ wf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">  </span> α не входит в типы в Γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, α wf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, x : α wf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, x : α ⊦ x : α</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, x : σ ⊦ e : τ <span class="math inline">  </span> Γ wf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ (λ <span class="math inline"><em>x</em><sub><em>σ</em></sub></span> . e) : σ → τ</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ x : σ → τ <span class="math inline">  </span> Γ ⊦ y : σ <span class="math inline">  </span> Γ wf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ x · y : τ</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Γ wf <span class="math inline">  </span> α ∈ Γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Γ ⊦ α : *</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Γ wf <span class="math inline">  </span> Γ ⊦ α : * <span class="math inline">  </span> Γ ⊦ β : *</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Γ ⊦ α → β : *</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Γ, α wf <span class="math inline">  </span> Γ, α ⊦ β : *</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Γ ⊦ ∀α.β : *</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Γ ⊦ ∀ α . β : * <span class="math inline">  </span> Γ, α : * ⊦ M : β</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Γ ⊦ Λα.M : ∀α . β</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ X : ∀α.β <span class="math inline">  </span> Γ ⊦ γ : *</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ X · γ : β[α := γ]</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">  </span> <span class="math inline"><em>c</em><sub><em>α</em></sub></span> — постоянная типа α</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ c: α</td>
</tr>
</tbody>
</table>
</div>
</section><div><a class="slider-prev" href="#математические-модели-вычислений"></a><a class="slider-next" href="#пример-чего-мы-хотим-добиться"></a></div>
<section id="пример-чего-мы-хотим-добиться" class="slide level1">
<h1>Пример: чего мы хотим добиться?</h1>
<p>В прошлый раз мы рассматривали пример того, как λ-исчисление с простыми типами может использоваться для проверки типов простого императивного языка программирования. Проверялось, что функции передаются аргументы именно тех типов, которые ожидаются согласно её определению.</p>
<p>Более амбициозная задача для проверки типов: контролировать нетривиальные свойства кода, например, определять при компиляции ошибки типа «выход за границы массива».</p>
</section><div><a class="slider-prev" href="#система-f-λ2-прошлое-занятие"></a><a class="slider-next" href="#пример-метод-прогонки"></a></div>
<section id="пример-метод-прогонки" class="slide level1">
<h1>Пример: метод прогонки</h1>
<pre><code>// Tridiagonal algorithm (solution for the tridiagonal system of linear equations)
// (d, c, e) - matrix of the linear system
// n - matrix size
// d - diagonal elements
// c - subdiagonal elements
// e - superdiagonal elements
// a - superdiagonal gaussian elimination coefficients
// b - right hand side
// x - answer
void tridiagonal(int n, double\* d, double\* c, 
    double\* e, double\* a, double\* b, int\* x) {

    a[1] = -e[0] / d[0]; 
    b[1] = b[0]  / d[0];

    for (int i=1; i &lt; n; i++) {
        double denominator = d[i] + c[i]\*a[i];
        a[i+1] = -e[i]  / denominator;
        b[i+1] = (1. - c[i])\*b[i] / denominator;
    }

    x[n] = (1. - c[n])\*b[n]\*(d[n] + c[n]\*a[n]); 
    for (int j=n-1; j &gt;=0; j--) {
        x[i] = a[i]\*x[i+1] + b[i+1];
    }
}</code></pre>
</section><div><a class="slider-prev" href="#пример-чего-мы-хотим-добиться"></a><a class="slider-next" href="#прогонка-с-простыми-типами"></a></div>
<section id="прогонка-с-простыми-типами" class="slide level1">
<h1>Прогонка с простыми типами</h1>
<pre class="coq"><code>Variable (int double DoubleArray IntArray : Type).
Variable (toInt : nat -&gt; int) (toDouble : nat -&gt; double).
Variable (set : DoubleArray -&gt; int -&gt; double -&gt; unit)
  (get : DoubleArray -&gt; int -&gt; double)
  (add sub div mul : double -&gt; double -&gt; double)
  (neg : double -&gt; double)
  (inc dec : int -&gt; int)
  (loop : int -&gt; int -&gt; (int -&gt; unit) -&gt; unit).

Definition tridiagonal (n : int) (d c e a b : DoubleArray) (x : IntArray) := (
  set a (toInt 1) (div (neg (get e (toInt 0))) (get d (toInt 0))),
  set b (toInt 1) (div (get b (toInt 0)) (get d (toInt 0))),

  loop (toInt 1) n (fun i =&gt; let 
    denominator := (add (get d i) (mul (get c i) (get a i))) in
    let body := (
      set a (inc i) (div (get e i) denominator),
      set b (inc i) (div (mul (sub (toDouble 1) (get c i)) (get b i)) denominator)
    )
    in tt),

  set x n (mul (mul (sub (toDouble 1) (get c n)) (get b n)) (add (get d n) (mul (get c n) (get a n)))),
  loop (dec n) (toInt 0) (fun j =&gt;  let
    body := set x j (add (get b (inc j)) (mul (get a j) (get x (inc i))))
  in tt)
).</code></pre>
</section><div><a class="slider-prev" href="#пример-метод-прогонки"></a><a class="slider-next" href="#операторы-над-типами"></a></div>
<section id="операторы-над-типами" class="slide level1">
<h1>Операторы над типами</h1>
<h2 id="как-определить-тип-абстрактного-массива">Как определить тип абстрактного массива?</h2>
<ul>
<li class="fragment"><p>λ (x : α). M — абстракция термов по термам<br>
λ (x : int). x</p></li>
<li class="fragment"><p>Λ (α : *). M — абстракция термов по типам<br>
Λ (α : *) (β : *) . λ (p : α × β) . fst p</p></li>
<li class="fragment"><p>Требуется — абстракция типов по типам</p></li>
</ul>
<p>α — тип (type)<br>
* — вид (kind, «тип типов»)</p>
<p>Для абстракции типов по типам нужно «перенести» λ-исчисление с простыми типами на уровень выше («λ-исчисление с простыми видами»).</p>
<p>κ = * | κ<sub>1</sub> ⇒ κ<sub>2</sub></p>
<p>⇒ — временно обозначим «стрелку» между видами</p>
<p>Абстрактный массив:<br>
Array : * ⇒ * — конструктор типа<br>
Array · double : * — тип</p>
</section><div><a class="slider-prev" href="#прогонка-с-простыми-типами"></a><a class="slider-next" href="#исчисление-λω"></a></div>
<section id="исчисление-λω" class="slide level1 inference">
<h1>Исчисление λω</h1>
<p>κ = * | κ<sub>1</sub> ⇒ k<sub>2</sub></p>
<p>Введение:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, α : κ<sub>1</sub> ⊦ A : κ<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ λ (α : κ<sub>1</sub>).A : κ<sub>1</sub> ⇒ κ<sub>2</sub></td>
</tr>
</tbody>
</table>
<p>Удаление:<br>
Γ ⊦ A : κ<sub>1</sub> ⇒ κ<sub>2</sub> <span class="math inline">  </span> Γ ⊦ B : κ<sub>1</sub><br>
--------------------------------------------<br>
Γ ⊦ A · B : κ<sub>2</sub></p>
<p>Дополнение существующих правил:<br>
∀ (α : κ) . …, Λ (α : κ) . …</p>
<p>β-редукция распространяется теперь и на типы.</p>
</section><div><a class="slider-prev" href="#операторы-над-типами"></a><a class="slider-next" href="#эквивалентность-типов-в-λω"></a></div>
<section id="эквивалентность-типов-в-λω" class="slide level1">
<h1>Эквивалентность типов в λω</h1>
<p>Типы α и (λ(t : *).t) · α должны быть эквивалентны.</p>
<p>Эквивалентность типов определяется в терминах нормализации.<br>
Пусть исчисление сильно нормализуемо (для λ-исчисления с простыми видами, это верно). Тогда два типа одного вида эквивалентны, если они приводятся β-редукцией к одинаковой нормальной форме.</p>
</section><div><a class="slider-prev" href="#исчисление-λω"></a><a class="slider-next" href="#примеры-типов-в-λω"></a></div>
<section id="примеры-типов-в-λω" class="slide level1">
<h1>Примеры типов в λω</h1>
<p>Массив с операциями:<br>
Array : * ⇒ *<br>
new : ∀ (α : *). int -&gt; Array · α<br>
get : ∀(α : *). Array · α → int → α<br>
set : ∀(α : *). Array · α → int → α → T</p>
</section><div><a class="slider-prev" href="#эквивалентность-типов-в-λω"></a><a class="slider-next" href="#прогонка-в-λω"></a></div>
<section id="прогонка-в-λω" class="slide level1">
<h1>Прогонка в λω</h1>
<pre class="coq"><code>Variable (int double : Type).
Variable (Array : Type -&gt; Type)
    (set : forall {T : Type}, Array T -&gt; int -&gt; T -&gt; unit)
    (get : forall {T : Type}, Array T -&gt; int -&gt; T).
Variable (toInt : nat -&gt; int) (toDouble : nat -&gt; double).
Variable 
  (add sub div mul : double -&gt; double -&gt; double)
  (neg : double -&gt; double)
  (inc dec : int -&gt; int)
  (loop : int -&gt; int -&gt; (int -&gt; unit) -&gt; unit).

Definition tridiagonal (n : int) (d c e a b : Array double) (x : Array int) := (
  set a (toInt 1) (div (neg (get e (toInt 0))) (get d (toInt 0))),
  set b (toInt 1) (div (get b (toInt 0)) (get d (toInt 0))),

  loop (toInt 1) n (fun i =&gt; let 
    denominator := (add (get d i) (mul (get c i) (get a i))) in
    let body := (
      set a (inc i) (div (get e i) denominator),
      set b (inc i) (div (mul (sub (toDouble 1) (get c i)) (get b i)) denominator)
    )
    in tt),

  set x n (mul (mul (sub (toDouble 1) (get c n)) (get b n)) (add (get d n) (mul (get c n) (get a n)))),
  loop (dec n) (toInt 0) (fun j =&gt;  let
    body := set x j (add (get b (inc j)) (mul (get a j) (get x (inc j))))
  in tt)
).</code></pre>
</section><div><a class="slider-prev" href="#примеры-типов-в-λω"></a><a class="slider-next" href="#соответствие-карри-говарда-в-λω"></a></div>
<section id="соответствие-карри-говарда-в-λω" class="slide level1">
<h1>Соответствие Карри-Говарда в λω</h1>
<p>Тип равенств между типами (тип идентичности по Лейбницу):<br>
Eq = λ (α β : *). ∀ (φ : * ⇒ *). φ α → φ β</p>
<p>Свойство рефлексивности задаёт конструктор равенства («введение»):<br>
refl : ∀(α : *). Eq α α<br>
refl = Λ(α : *). Λ(φ : * ⇒ *) . λ (x : φ α) . x</p>
<p>Доказуемы свойства симметричности и транзитивности:<br>
symm : ∀ (α β : *). Eq α β → Eq β α<br>
trans : ∀ (α β γ : *) . Eq α β → Eq β γ → Eq α γ</p>
<p>Доказательства:<br>
symm = Λ(α β : *). λ (e : Eq α β). e (λ (γ : *). Eq γ α) (refl α)<br>
trans = Λ(α β γ : *). λ (s : Eq α β) (t : Eq β γ). t (Eq α) s</p>
<p>Свойство подстановки по равенству:<br>
lift : ∀ (α β : * ). ∀ (φ : * ⇒ *). Eq α β → Eq (φ α) (φ β)<br>
lift = Λ (α β : *). Λ (φ : * ⇒ *). λ (e : Eq α β). e (λ (γ : *). Eq (φ α) (φ γ)) (refl (φ α))</p>
</section><div><a class="slider-prev" href="#прогонка-в-λω"></a><a class="slider-next" href="#к-зависимым-типам"></a></div>
<section id="к-зависимым-типам" class="slide level1">
<h1>К зависимым типам</h1>
<p>Мы определили следующие виды абстракции:</p>
<ul>
<li class="fragment"><p>λ (x : α). M — терм ↦ терм<br>
λ (x : int). x</p></li>
<li class="fragment"><p>Λ (α : *). M — тип ↦ терм<br>
Λ (α : *) (β : *) . λ (p : α × β) . fst p</p></li>
<li class="fragment"><p>λ (x : κ). A — тип ↦ тип<br>
Eq = λ (α β : *). ∀ (φ : * ⇒ *). φ α → φ β</p></li>
</ul>
<p>Соответствие Карри-Говарда для рассмотренных систем позволяет представлять в виде термов исчисление высказываний и различным его расширениям.</p>
<p>Для того, чтобы замкнуть граф возможных абстракций и перейти в исчисление предикатов не хватает последнего ребра:</p>
<h2 id="терм-тип">терм ↦ тип</h2>
</section><div><a class="slider-prev" href="#соответствие-карри-говарда-в-λω"></a><a class="slider-next" href="#λ-куб-барендрегта"></a></div>
<section id="λ-куб-барендрегта" class="slide level1">
<h1>λ-куб Барендрегта</h1>
<p><img src="images/lambda-cube.svg"><br>
Barendregt H.P. Introduction to generalized type systems // J. Funct. Program. 1991. Vol. 1, № 2. P. 125–154.<br>
Общая схема, примеры, ссылки на доказательства сильной нормализации для всех систем куба.</p>
</section><div><a class="slider-prev" href="#к-зависимым-типам"></a><a class="slider-next" href="#зависимое-произведение"></a></div>
<section id="зависимое-произведение" class="slide level1">
<h1>Зависимое произведение</h1>
<h2 id="πx-α.-a">Π(x : α). A</h2>
<p>α и A — типы, вместо x подставляется терм.</p>
<h2 id="массив-с-контролем-границ">Массив с контролем границ</h2>
<p>Array : * ⇒ int ⇒ *<br>
Array double 0<br>
Array double 10</p>
<p>Функция, связывающая n и длину массива:<br>
Π (n : int) (Array double n) → Array double n<br>
λ (n : int). (d : Array double n). d</p>
</section><div><a class="slider-prev" href="#λ-куб-барендрегта"></a><a class="slider-next" href="#исчисление-конструкций-λpω"></a></div>
<section id="исчисление-конструкций-λpω" class="slide level1 inference">
<h1>Исчисление Конструкций (λPω)</h1>
<p>τ = … | Π (x : α). A …</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, x : α ⊦ A : * <span class="math inline">  </span> Γ ⊦ α : *</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ Π (x : α). A : *</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ Π (x : α). A : * <span class="math inline">  </span> Γ, x : α ⊦ M : A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ λ (x : α). M : Π (x : α). A</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ F : Π (x : α). A <span class="math inline">  </span> Γ ⊦ N : α</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ F · N : A[x := α]</td>
</tr>
</tbody>
</table>
</section><div><a class="slider-prev" href="#зависимое-произведение"></a><a class="slider-next" href="#все-виды-абстракций-в-один"></a></div>
<section id="все-виды-абстракций-в-один" class="slide level1 inference">
<h1>Все виды абстракций — в один</h1>
<ol type="1">
<li class="fragment">Π (x : α). β, где β не зависит от x — то же самое, что α → β.</li>
<li class="fragment">Π (x : κ). N, где κ — вид.</li>
</ol>
<p>τ = * | b ∈ B | Π (x : A). B | α</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">  </span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">[] wf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">  </span> τ ∈ Γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, x : τ wf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">  </span> α не входит в типы в Γ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, α wf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, x : α wf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ, x : α ⊦ x : α</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ, x : α ⊦ A : * <span class="math inline">  </span> Γ ⊦ α : *</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ Π (x : α). A : *</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ Π (x : α). A : * <span class="math inline">  </span> Γ, x : α ⊦ M : A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ λ (x : α). M : Π (x : α). A</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ F : Π (x : α). A <span class="math inline">  </span> Γ ⊦ N : α</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ F · N : A[x := α]</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf <span class="math inline">  </span> <span class="math inline"><em>c</em><sub><em>α</em></sub></span> — постоянная типа α</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ c: α</td>
</tr>
</tbody>
</table>
<div style="color: red; display: inline-block">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ * : *</td>
</tr>
</tbody>
</table>
</div>
</section><div><a class="slider-prev" href="#исчисление-конструкций-λpω"></a><a class="slider-next" href="#универсумы"></a></div>
<section id="универсумы" class="slide level1 inference">
<h1>Универсумы</h1>
<h2 id="парадокс-бурали-форти-в-исчислении-конструкций">Парадокс Бурали-Форти в исчислении конструкций</h2>
<p><span class="math inline"><strong>T</strong><strong>y</strong><strong>p</strong><strong>e</strong></span> — универсум («тип всех типов»), в общем случаи такие конструкции опасны, т.к. позволяют определить парадоксы.</p>
<div style="color: red; display: inline-block">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ wf</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ Type : Type</td>
</tr>
</tbody>
</table>
</div>
<p>— рекурсивное включение универсумов, которое мы дали в первом правиле редукции сегодняшней лекции: <span class="math inline"><strong>T</strong><strong>y</strong><strong>p</strong><strong>e</strong> : <strong>T</strong><strong>y</strong><strong>p</strong><strong>e</strong></span>. Оно делает противоречивым даже System F<span class="math inline"><sub><em>ω</em></sub></span> — полиморфное λ-исчисление с конструкторами типов.</p>
</section><div><a class="slider-prev" href="#все-виды-абстракций-в-один"></a><a class="slider-next" href="#парадокс"></a></div>
<section id="парадокс" class="slide level1">
<h1>Парадокс</h1>
<p>Hurkens A.J.C. A simplification of Girard’s paradox // Typed Lambda Calculi and Applications / ed. Dezani-Ciancaglini M., Plotkin G. Berlin, Heidelberg: Springer Berlin Heidelberg, 1995. Vol. 902. P. 266–278.</p>
<div style="font-size:0.8em">
<span class="math inline">2<sup><em>S</em></sup></span> ≡ Pow ≡ λ (S : Type). Π S . Type<br>
Univ ≡ Π (X : Type). (Π (Π <span class="math inline">2<sup>2<sup><em>X</em></sup></sup></span> . X). <span class="math inline">2<sup>2<sup><em>X</em></sup></sup></span>)<br>
PPUniv ≡ <span class="math inline">2<sup>2<sup><em>U</em><em>n</em><em>i</em><em>v</em></sup></sup></span><br>
τ ≡ λ (t : PPUniv) (X : Type) (f : Π <span class="math inline">2<sup>2<sup><em>X</em></sup></sup></span> . X ) (p : <span class="math inline">2<sup><em>X</em></sup></span> ) .<br>
t · (λ (x : Univ) . (p (f ((x X) f))))<br>
σ ≡ λ (s : Univ) . ((s · Univ) (λ (t : PPUniv) . τ · t))<br>
Δ ≡ λ (y : Univ) . (Π (Π (p : (Pow Univ)). (σ y p) (p (τ (σ y)))) ⊥)<br>
Ω ≡ (τ · (λ (p : 2<sup>Univ</sup>)) · (Π (x : Univ). (σ · x · p) · (p · x)))<br>
False ≡ (λ (O : (Π (p : 2<sup>Univ</sup>) (Π (x : Univ) . (σ · x · p) · (p · x)) (p · Ω) )).<br>
(((O Δ) (λ (x : Univ) (t : σ x Δ) (u : (Π (p : (Pow Univ)). (σ y p) (p (τ (σ y))))).<br>
(u · (λ (y : Univ)) (p (τ (σ y)))))))<br>
· (λ (p : 2<sup>Univ</sup>) . (O (λ (y : Univ) . p (τ (σ y)))))<br>
· (λ (p : 2<sup>Univ</sup>). (v : (Π (x : Univ). (σ x p) (p x))).<br>
(v · Ω) · (λ (x : Univ) . (v · (τ (σ x))))))<br>
False : ⊥
</div>
<p>Терм False не нормализуем.</p>
</section><div><a class="slider-prev" href="#универсумы"></a><a class="slider-next" href="#уровни-универсумов"></a></div>
<section id="уровни-универсумов" class="slide level1 inference">
<h1>Уровни универсумов</h1>
<p>Для того, чтобы избежать таких парадоксов, рассматривают не один универсум Type : Type, а их набор Type<sub>i</sub>, где i — какой-то набор индексов с заданным строгим порядком &lt;.<br>
Обычно используется что-то вроде решётки, чтобы у любой пары индексов был максимальный индекс max, нестрого больший i, j ⩽ max(i,j).</p>
<p>Тогда правило типизации универсума преобразуется к следующему виду:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">i &lt; j</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Type<sub>i</sub> : Type<sub>j</sub></td>
</tr>
</tbody>
</table>
</section><div><a class="slider-prev" href="#парадокс"></a><a class="slider-next" href="#уровни-универсумов-1"></a></div>
<section id="уровни-универсумов-1" class="slide level1 inference">
<h1>Уровни универсумов</h1>
<p>А правила типизации зависимого произведения — к виду:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Γ, x : α ⊦ A : Type<sub>i</sub> <span class="math inline">  </span> Γ ⊦ α : Type<sub>j</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Γ ⊦ Π (x : α). A : Type<sub>max(i,j)</sub></td>
</tr>
</tbody>
</table>
<p>При проверке типов индексы строятся в виде ориентированного графа, рёбра которого помечены &lt; и ⩽, а потом, например, алгоритмом Тарьяна, определяется, можно ли получить на основе этого графа требуемый порядок (можно, если нет ориентированного цикла с одним из рёбер, помеченных &lt;).</p>
<p>Luo Z. ECC, an extended calculus of constructions // [1989] Proceedings. Fourth Annual Symposium on Logic in Computer Science. IEEE Comput. Soc. Press, 1989. P. 386–395.</p>
</section><div><a class="slider-prev" href="#уровни-универсумов"></a><a class="slider-next" href="#массив-с-контролем-границ-1"></a></div>
<section id="массив-с-контролем-границ-1" class="slide level1">
<h1>Массив с контролем границ</h1>
<p>Длина массива — неотрицательное целое число, это не то же самое, что int. Далее обозначаем ℕ (в Coq — nat, встроенный тип натуральных чисел с нулём).</p>
<p>S : ℕ → ℕ</p>
<p>· &lt; · : ℕ → ℕ → Type</p>
<p>succ_lt : Π (n : ℕ). n &lt; S n</p>
<p>Array : Type → ℕ → Type</p>
<p>Функция получения элемента:<br>
get : Π (T : Type). (n : ℕ). (a : Array T n). (i : ℕ). (i &lt; n) → T</p>
<p>Массивы зависимой длины:<br>
λ (n : ℕ). (d : Array double (S n)). (c e : Array double n). (a b x : Array n). …</p>
</section><div><a class="slider-prev" href="#уровни-универсумов-1"></a><a class="slider-next" href="#зависимая-сумма-пара-терм-свойство"></a></div>
<section id="зависимая-сумма-пара-терм-свойство" class="slide level1 inference">
<h1>Зависимая сумма (пара «терм — свойство»)</h1>
<p>Зависимое произведение Π (x : A). B обобщает тип функций A → B таким образом, что тип B зависит от значения X. Можно считать</p>
<p>Аналогично, зависимая сумма Σ (x : A). B обобщает тип пар A * B:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ A : Type<sub>i</sub> <span class="math inline">  </span> Γ,A ⊦ B : Type<sub>j</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ Σ(x : A).B : Type<sub>max(i,j)</sub></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Γ ⊦ Σ(x : A).B : Type<sub>k</sub> <span class="math inline">  </span> Γ ⊦ a : A <span class="math inline">  </span> Γ ⊦ b : B[x := a]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Γ ⊦ pair<sub>ΣA.B</sub>(a, b) : Σ(x:A).B</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Γ ⊦ a : Σ(x:A).B&nbsp; <span class="math inline">  </span> Γ, s : Σ(x:A).B ⊦ C : Type <span class="math inline">  </span> Γ, a : A, b : B ⊦ r : C · pair(a, b)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Γ ⊦ split(C, s, r) : C · s</td>
</tr>
</tbody>
</table>
<p>split — пример терма <strong>зависимого удаления</strong>. Он выразим через <strong>fst</strong>, <strong>snd</strong> только в исчислении с η-расширением, а для такого исчисления на настоящее время нет доказательства сильной нормализации.</p>
<p>Функция, которая возвращает массив, имеющий длину не менее заданной:<br>
Π (n : ℕ) . Σ (m : ℕ) (p : n &lt; m). (b : Array double m)</p>
<p>Функция, которая факторизует число:<br>
Π (n : ℕ). Σ (m : ℕ). (Eq 0 (mod n m))</p>
</section><div><a class="slider-prev" href="#массив-с-контролем-границ-1"></a><a class="slider-next" href="#разрешимые-свойства"></a></div>
<section id="разрешимые-свойства" class="slide level1">
<h1>Разрешимые свойства</h1>
<p>В некоторых случаях задавать какие-то ограничения на этапе компиляции затруднительно, лучше принимать решение в процессе исполнения.</p>
<p>Сравнение <code>a &lt; b</code> можно представить в более типизированном и менее типизированном виде:</p>
<p>Менее типизированный:<br>
compare(a, b) : Bool</p>
<p>Более типизированный (разрешение свойства <code>a&lt;b</code>):<br>
compare(a, b) : {a &lt; b} + { b ⩽ a }</p>
<p>В последнем случае оператор удаления <code>case</code> может передать полученный тип далее. В языках с зависимыми типами использовать «менее типизированный» способ разрешения свойств почти никогда не имеет смысла.</p>
</section><div><a class="slider-prev" href="#зависимая-сумма-пара-терм-свойство"></a><a class="slider-next" href="#прогонка-в-λpω"></a></div>
<section id="прогонка-в-λpω" class="slide level1">
<h1>Прогонка в λPω</h1>
</section><div><a class="slider-prev" href="#разрешимые-свойства"></a><a class="slider-next" href="#что-осталось-непроверенным"></a></div>
<section id="что-осталось-непроверенным" class="slide level1">
<h1>Что осталось непроверенным</h1>
<ul>
<li class="fragment">корректная последовательность доступа к элементам массива</li>
<li class="fragment">корректность результата (после обработки для матрицы с диагональным преобладанием в массиве x должно быть решение исходной системы линейных уравнений).</li>
</ul>
</section><div><a class="slider-prev" href="#прогонка-в-λpω"></a><a class="slider-next" href="#литература"></a></div>
<section id="литература" class="slide level1">
<h1>Литература</h1>
<ol type="1">
<li class="fragment">Б. Пирс. Типы в языках программирования. 2010</li>
<li class="fragment">Henk Barendregt, Wil Dekkers, Richard Statman. Lambda Calculus With Types. Cambridge University Press, 2010.</li>
<li class="fragment">М. Кривчиков. Формальные модели и верификация свойств программ с использованием промежуточного представления. Глава 1, раздел 2.1, подраздел 3.2.6.<br>
<a href="http://istina.msu.ru/media/dissertations/dissertation/25c/edc/10283583/dissertation_1.pdf" class="uri">http://istina.msu.ru/media/dissertations/dissertation/25c/edc/10283583/dissertation_1.pdf</a></li>
</ol>
</section><div><a class="slider-prev" href="#что-осталось-непроверенным"></a><a class="slider-next" href="#задачи"></a></div>
<section id="задачи" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 7.1 *</strong></dt>
<dd class="fragment">Записать тип равенства, его свойства и их доказательства в Coq так, чтобы они прошли проверку типов.
</dd>
<dt class="fragment"><strong>Задача 7.2 **</strong></dt>
<dd class="fragment">Записать парадокс, вызванный циклической иерархией универсумов, в Coq и убедиться, что он не проходит проверку типов.<br>
Тип ⊥ в Coq обозначается False.
</dd>
<dt class="fragment"><strong>Задача 7.3 **</strong></dt>
<dd class="fragment">Записать в Coq (или в термах исчисления конструкций) тип функции, реализующей метод прогонки, с условием корректности ответа.
</dd>
</dl>
</section><div><a class="slider-prev" href="#литература"></a><a class="slider-next" href="#задачи-1"></a></div>
<section id="задачи-1" class="slide level1">
<h1>Задачи</h1>
<dl>
<dt class="fragment"><strong>Задача 7.4 ***</strong></dt>
<dd class="fragment">Предложить способ описания в Coq (или в термах исчисления конструкций) спецификации неинициализированного массива:<br>
Array : Type → ℕ → ?? → Type<br>
new : Π (T : Type) (n : ℕ) . Array T n (все элементы не инициализированы)<br>
get : Π (T : Type) (n : ℕ) (? : ??) (a : Array T n) (i : ℕ). (i &lt; n) → (элемент i инициализирован) → T<br>
set : Π (T : Type) (n : ℕ) (? : ??) (a : Array T n) (i : ℕ) (t : T). (i &lt; n) → Array T n (? + элемент i инициализирован)
</dd>
</dl>
</section><div><a class="slider-prev" href="#задачи"></a><a class="slider-next"></a></div>

<!-- start page -->
   <div id="slider">
       <a href="#математические-модели-вычислений" class="slider-start">PLAY</a>
   </div>

   <!-- progressbar container -->
   <div class="slider-progress"></div>
   </article>
  </div>

  
  <script type="text/javascript">
  document.addEventListener("keydown", function(e) {
     if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
     switch (e.keyCode) {
       case 35: // End
          var arr = document.querySelectorAll("a.slider-next:link");
          var a = arr[arr.length - 1];
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 36: // Home
          var a = document.querySelector("a.slider-start");
          if (a && a.href) {
            window.location = a.href;
          }
          break;
       case 37: // left arrow
         var a = document.querySelector("section:target ~ div a.slider-prev");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
       case 39: // right arrow
         var a = document.querySelector("section:target ~ div a.slider-next");
         if (a && a.href) {
           window.location = a.href;
         }
         break;
     }
  });
  </script>
  

</body></html>
